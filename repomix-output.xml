This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
cli/
  commands/
    function.mjs
    help.mjs
    index.mjs
    project.mjs
  commands.mjs
fixtures/
  tags.json
  test.c
lib/
  file.mjs
  functions.mjs
  tree.mjs
model/
  entity.mjs
  project.mjs
  relationship.mjs
  sourcecode.mjs
1753817175187-table_project.mjs
1753817176438-table_entity.mjs
1753817876593-index_entity.mjs
1753934080094-table_relationship.mjs
1754286548294-index_relationship.mjs
1754436391764-table_sourcecode.mjs
1754438557607-index_project.mjs
1754439911414-index_sourcecode.mjs
1754516227541-index_sourcecode_project_id.mjs
1754516260587-index_entity_project_id.mjs
1755887814675-matview_project_stats.mjs
cb
db.mjs
functions.mjs
index.mjs
project.mjs
search.mjs
sourcecode.mjs
strings.mjs
tree.mjs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="cb">
#!/usr/bin/env node

'use strict';

import parseArgs from 'minimist';
import { commands, handler } from '../lib/cli/commands.mjs';

const argv = parseArgs(process.argv.slice(2), { boolean: true });

const command = argv._.shift();

if (
  command === undefined ||
  commands[command] === undefined ||
  argv.help ||
  argv.h
) {
  argv._.unshift(command);
  commands.help.handler(argv);
} else {
  try {
    await handler(command, argv);
  } catch (error) {
    console.error(error.message);
    //process.exit(1);
  }
}

process.exit(0);
</file>

<file path="cli/commands/function.mjs">
'use strict';

import { get_project_by_name } from '../../model/project.mjs';
import {
  get_entity_symbols,
  entity_search,
  get_entity
} from '../../model/entity.mjs';
import {
  get_entities_by_caller_id,
  get_entities_by_callee_id
} from '../../model/relationship.mjs';

const help = `usage: cb function [<args>]

Gives access to functions, allowing for listing, searching, and usage of functions.

  * list - Provides a list of known functions
  * search - Searches for a function
  * retrieve - Retrieves the function and information about it
  * callers - Lists any functions that call this function
  * callees - Lists any functions that this function calls
`;

const list_help = `usage: cb function list --project=<project_name> [--filename=<file_name>]

List all functions that are currently known.
`;

const search_help = `usage: cb function search --name=[name] [--project=<project>] [--filename=<filename>]

Search for a function by name.  Partial matches will be returned, and the
search is case-insensitive.

Arguments:

  * --name=[name] - Name of the function to search for (required)
  * --project=[project] - Name of the project to narrow the search
  * --filename=[filename] - Name of the file to search in
`;

const retrieve_help = `usage: cb function retrieve --name=[name] [--project=<project>] [--filename=<filename>]

Retrieve the function and information about it.

Arguments:

  * --name=[name] - Name of the function to retrieve (required)
  * --project=[project] - Name of the project to narrow the search
  * --filename=[filename] - Name of the file to search in
`;

const callers_help = `usage: cb function caller --name=[name] [--project=<project>] [--filename=<filename>]

Retrieve all callers known for a function and information for them.

Arguments:

  * --name=[name] - Name of the function to retrieve callers for (required)
  * --project=[project] - Only retrieve callers from this project
`;

const callees_help = `usage: cb function caller --name=[name] [--project=<project>] [--filename=<filename>]

Retrieve all callees known for a function and information for them.

Arguments:

  * --name=[name] - Name of the function to retrieve callees for (required)
  * --project=[project] - Only retrieve callees from this project
`;

const function_list = async ({ project, filename }) => {
  const projects = await get_project_by_name({ name: project });

  if (projects.length === 0) {
    throw new Error(`Project '${project}' not found`);
  }

  const symbols = await get_entity_symbols({
    project_id: projects[0].id,
    filename,
    type: 'function'
  });

  console.log(`Functions:\n`);
  for (const symbol of symbols) {
    console.log(
      `  * ${symbol.symbol}${symbol.parameters} - ${symbol.filename}:${symbol.start_line}`
    );
  }
};

const function_search = async ({ name, project, filename, limit }) => {
  let project_id;
  if (project !== undefined) {
    const projects = await get_project_by_name({ name: project });

    if (projects.length !== 0) {
      project_id = projects[0].id;
    }
  }

  const results = await entity_search({
    project_id,
    filename,
    symbol: name,
    type: 'function',
    limit
  });

  if (results.length === 0) {
    throw new Error(`Function '${name}' not found`);
  }

  console.log(`Functions:\n`);
  for (const symbol of results) {
    console.log(
      `  * ${symbol.symbol}${symbol.parameters} - ${symbol.filename}:${symbol.start_line}`
    );
  }
};

const function_retrieve = async ({ name, project, filename }) => {
  let project_id;
  if (project !== undefined) {
    const projects = await get_project_by_name({ name: project });

    if (projects.length !== 0) {
      project_id = projects[0].id;
    }
  }

  const results = await get_entity({
    project_id,
    filename,
    symbol: name,
    type: 'function'
  });

  if (results.length === 0) {
    throw new Error(`Function '${name}' not found`);
  }

  // We should only have one function.
  const [function_symbol] = results;
  console.log(`Function:\n`);
  console.log(
    `${function_symbol.symbol}${function_symbol.parameters} - ${function_symbol.filename}:${function_symbol.start_line}

${function_symbol.comment}
${function_symbol.source}
`
  );
};

const function_callers = async ({ name, project }) => {
  let project_id;
  if (project !== undefined) {
    const projects = await get_project_by_name({ name: project });

    if (projects.length !== 0) {
      project_id = projects[0].id;
    }
  }

  const results = await get_entities_by_callee_id({
    project_id,
    symbol: name,
    type: 'function'
  });

  if (results.length === 0) {
    throw new Error(`Function '${name}' not found`);
  }

  console.log(`Calls made to ${name}:\n`);
  // Iterate through the function symbols and print them.
  for (const caller of results) {
    console.log(
      `  * ${caller.caller_symbol} ${caller.caller_filename}:${caller.caller_start_line}`
    );
  }
};

const function_callees = async ({ name, project }) => {
  let project_id;
  if (project !== undefined) {
    const projects = await get_project_by_name({ name: project });

    if (projects.length !== 0) {
      project_id = projects[0].id;
    }
  }

  const results = await get_entities_by_caller_id({
    project_id,
    symbol: name,
    type: 'function'
  });

  if (results.length === 0) {
    throw new Error(`Function '${name}' not found`);
  }

  console.log(`Calls made from ${name}:\n`);
  // Iterate through the function symbols and print them.
  for (const caller of results) {
    console.log(
      `  * ${caller.callee_symbol}${caller.callee_parameters} ${caller.caller_filename}:${caller.relationship_line} => ${caller.callee_filename}:${caller.callee_start_line}`
    );
  }
};

const func = {
  command: 'function',
  description: 'Tools for querying functions',
  commands: {
    list: function_list,
    search: function_search,
    retrieve: function_retrieve,
    callers: function_callers,
    callees: function_callees
  },
  help,
  command_help: {
    list: list_help,
    search: search_help,
    retrieve: retrieve_help,
    callers: callers_help,
    callees: callees_help
  },
  command_arguments: {
    list: {
      project: {
        type: 'string',
        description: 'Name of the project',
        required: true
      },
      filename: {
        type: 'string',
        description: 'Filename to limit list to'
      }
    },
    search: {
      name: {
        type: 'string',
        description: 'Name of the function to search for',
        required: true
      },
      project: {
        type: 'string',
        description: 'Name of the project'
      },
      filename: {
        type: 'string',
        description: 'Filename to limit list to'
      },
      limit: {
        type: 'number',
        description: 'Maximum number of results to return (default 10)'
      }
    },
    retrieve: {
      name: {
        type: 'string',
        description: 'Name of the function to retrieve',
        required: true
      },
      project: {
        type: 'string',
        description: 'Name of the project'
      },
      filename: {
        type: 'string',
        description: 'Filename to limit list to'
      }
    },
    callers: {
      name: {
        type: 'string',
        description: 'Name of the function to find callers for',
        required: true
      },
      project: {
        type: 'string',
        description: 'Name of the project'
      },
      filename: {
        type: 'string',
        description: 'Filename to limit list to'
      }
    },
    callees: {
      name: {
        type: 'string',
        description: 'Name of the function to find callees for',
        required: true
      },
      project: {
        type: 'string',
        description: 'Name of the project'
      },
      filename: {
        type: 'string',
        description: 'Filename to limit list to'
      }
    }
  }
};

export { func };
</file>

<file path="cli/commands/help.mjs">
'use strict';

import { project } from './project.mjs';
import { func } from './function.mjs';

const help_text = `usage: cb [--version] [--help] <command> [<args>]

You can use '--help' or '-h' to get help for a specific command.

Commands available:

${project.command} - ${project.description}
${func.command} - ${func.description}
`;

// Commands that we know about.
const commands = {
  project,
  function: func
};

// Help uses a single handler function to provide help for specific commands.
const handler = async (argv) => {
  // Get the command that we are providing help for.
  const command = argv._.shift();

  // Get the subcommand.
  const subcommand = argv._.shift();

  if (commands[command]) {
    if (subcommand && commands[command].commands[subcommand]) {
      if (!commands[command].command_help[subcommand]) {
        console.log(`No help available for ${command} ${subcommand}`);
      } else {
        console.log(commands[command].command_help[subcommand]);
      }
    } else {
      console.log(commands[command].help);
    }
  } else if (command) {
    console.log(`Unknown command: ${command}`);
  } else {
    console.log(help_text);
  }
};

const help = {
  command: 'help',
  description: 'Display this help message',
  handler,
  help: help_text
};

export { help };
</file>

<file path="cli/commands/index.mjs">
'use strict';

export * from './help.mjs';
export * from './project.mjs';
export * from './function.mjs';
</file>

<file path="cli/commands/project.mjs">
'use strict';

import { create_project, refresh_project } from '../../project.mjs';
import {
  get_all_projects_with_metadata,
  get_project_by_name
} from '../../model/project.mjs';
import { get_function_counts } from '../../model/entity.mjs';

const help = `usage: cb project [<args>]

Gives access to projects, allowing for creation, updating, and listing.

  * list - Provides a list of projects currently known
  * import - Imports a project and its source
  * refresh - Refreshes the data for a project
  * info - Provides information about a project
`;

const list_help = `usage: cb project list

List all projects that are currently known.
`;
const import_help = `usage: cb project import --path=[path] --name=[name]

Import a new project, importing its source code into the system.

Arguments:

  * --path=[path] - Path of the project to import (required)
  * --name=[name] - Name of the project (required)
`;

const refresh_help = `usage: cb project refresh --name=[name]

Refresh the source of a project.

Arguments:

  * --name=[name] - Name of the project
`;

const info_help = `usage: cb project info --name=[name]

Provides specific information about a project including its path, and
source files associated with it.

Arguments:

  * --name=[name] - Name of the project (required)
`;

const project_list = async () => {
  const projects = await get_all_projects_with_metadata();
  console.log('Projects:');
  projects.forEach((project) => {
    console.log(`
${project.name}

  - Path: ${project.path}
  - Created: ${project.created_at.toLocaleString()}
  - Updated: ${project.updated_at.toLocaleString()}
  - Entities: ${project.entity_count}
  - Source Files: ${project.source_count}
`);
  });
};

const project_import = async ({ name, path }) => {
  await create_project({ name, path });
};

const project_refresh = async ({ name }) => {
  await refresh_project({ name });
};

const project_info = async ({ name }) => {
  const project = await get_project_by_name({ name });

  if (project.length === 0) {
    throw new Error(`Project '${name}' not found`);
  }

  console.log(`Project: ${project[0].name}
Path: ${project[0].path}
`);

  const filenames = await get_function_counts({ project_id: project[0].id });

  if (filenames.length === 0) {
    console.log(`No functions found.`);
  } else {
    for (const filename of filenames) {
      console.log(
        `  * ${filename.filename} - ${filename.function_count} functions`
      );
    }
  }
};

const project = {
  command: 'project',
  description: 'Tools for managing projects',
  commands: {
    list: project_list,
    import: project_import,
    refresh: project_refresh,
    info: project_info
  },
  help,
  command_help: {
    list: list_help,
    import: import_help,
    refresh: refresh_help,
    info: info_help
  },
  command_arguments: {
    import: {
      path: {
        type: 'string',
        description: 'Path of the project to import',
        required: true
      },
      name: {
        type: 'string',
        description: 'Name of the project',
        required: true
      }
    },
    refresh: {
      name: {
        type: 'string',
        description: 'Name of the project',
        required: true
      }
    },
    info: {
      name: {
        type: 'string',
        description: 'Name of the project',
        required: true
      },
      filename: {
        type: 'string',
        description: 'File name to get information on',
        required: false
      }
    }
  }
};

export { project };
</file>

<file path="cli/commands.mjs">
'use strict';

import { help, project, func } from './commands/index.mjs';

// A list of the commands for the CLI.
const commands = {
  help,
  project,
  function: func
};

const handler = async (command, argv) => {
  if (commands[command] === undefined) {
    commands.help.handler(argv);
  }

  // Get a copy of the subcommand.
  const subcommand = argv._[0];

  // Try to execute the command or subcommand, catch any errors and display a
  // message if there is an error.
  try {
    if (commands[command].commands[subcommand]) {
      argv._.shift();

      // Check the arguments, and if they are not there give the missing argument
      // error message and respond with help.
      if (commands[command].command_arguments?.[subcommand]) {
        const required_args = required_arguments(
          commands[command].command_arguments[subcommand]
        );

        const missing = argument_check(
          argv,
          commands[command].command_arguments[subcommand]
        );
        if (missing.length > 0) {
          console.error(
            `Missing or incorrect arguments: ${missing.join(', ')}\n`
          );

          // Take us back to an unmodified state so we can just call help.
          argv._.unshift(subcommand);
          argv._.unshift(command);

          // Call the help handler with the modified arguments.
          commands.help.handler(argv);

          return;
        }
      }

      // Call the subcommand.
      await commands[command].commands[subcommand](argv);
    } else if (commands[command].handler) {
      // There is no subcommand handler, so we can just call the command.
      await commands[command].handler(argv);
    } else {
      argv._.unshift(command);
      commands.help.handler(argv);
    }
  } catch (error) {
    console.log(`Error: ${error.message}`);
    //process.exit(1);
  }
};

/**
 * Returns an array with the keys of the required arguments
 * for a given sub‑command.
 *
 * @param {string} command - The name of the sub‑command (e.g. "import").
 * @param {object} args - An object containing the arguments (e.g. ["--path", "--name"]).
 * @returns {string[]} Array of required argument keys.
 */
function required_arguments(args) {
  if (!args) {
    return [];
  } // No such command in the spec.

  const req = [];
  for (const key in args) {
    if (args[key].required) {
      req.push(key);
    }
  }
  return req;
}

// Check to make sure the required arguments are present and valid.
const argument_check = (argv, expected) => {
  const required = required_arguments(expected);

  // Find any missing arguments.
  const missing = required.filter((arg) => {
    return !argv[arg] || expected[arg].type !== typeof argv[arg];
  });

  return missing;
};

export { commands, handler, argument_check };
</file>

<file path="model/entity.mjs">
'use strict';

import { query } from '../db.mjs';

const insert_or_update_entity = async (entity) => {
  try {
    const ret = await query`
    INSERT INTO entity (
      project_id,
      language,
      symbol,
      type,
      filename,
      source,
      start_line,
      end_line,
      parameters,
      comment,
      return_type,
      created_at
    ) VALUES (
      ${entity.project_id},
      ${entity.language},
      ${entity.symbol},
      ${entity.type},
      ${entity.filename},
      ${entity.source === undefined ? null : entity.source},
      ${entity.start_line},
      ${entity.end_line},
      ${entity.parameters === undefined ? null : entity.parameters},
      ${entity.comment === undefined ? null : entity.comment},
      ${entity.return_type},
      CURRENT_TIMESTAMP
    ) ON CONFLICT (project_id, language, symbol, type) DO UPDATE SET
      filename = ${entity.filename},
      source = ${entity.source === undefined ? null : entity.source},
      start_line = ${entity.start_line},
      end_line = ${entity.end_line},
      parameters = ${entity.parameters === undefined ? null : entity.parameters},
      comment = ${entity.comment === undefined ? null : entity.comment},
      return_type = ${entity.return_type},
      updated_at = CURRENT_TIMESTAMP
      RETURNING *
    `;

    return ret;
  } catch (error) {
    console.error(error);
    throw error;
  }
};

const get_entity = async ({ project_id, symbol, type, filename }) => {
  return await query`
    SELECT *
      FROM entity
     WHERE symbol = ${symbol}
       ${type !== undefined ? query`AND type = ${type}` : query``}
       ${filename !== undefined ? query`AND filename = ${filename}` : query``}
       ${project_id !== undefined ? query`AND project_id = ${project_id}` : query``}
     ORDER BY project_id, symbol
    `;
};

const get_entity_by_id = async (id) => {
  const entities = await query`
    SELECT *
      FROM entity
     WHERE id = ${id}
    `;

  return entities[0];
};

const get_entity_symbols = async ({ project_id, filename, type }) => {
  return await query`
    SELECT symbol,
           filename,
           parameters,
           start_line
      FROM entity
     WHERE project_id = ${project_id}
       ${filename !== undefined ? query`AND filename = ${filename}` : query``}
       ${type !== undefined ? query`AND type = ${type}` : query``}
     ORDER BY symbol ASC
    `;
};

const get_function_counts = async ({ project_id, filename }) => {
  return await query`
    SELECT filename,
           COUNT(id) AS function_count
      FROM entity
     WHERE type = 'function'
       ${filename !== undefined ? query`AND filename = ${filename}` : query``}
       ${project_id !== undefined ? query`AND project_id = ${project_id}` : query``}
     GROUP BY filename
     ORDER BY filename ASC
    `;
};

const entity_search = async ({
  symbol,
  project_id,
  filename,
  type,
  limit = 10
}) => {
  return await query`
    SELECT similarity(symbol, ${symbol}) AS sim,
           entity.*
      FROM entity
     WHERE symbol ilike ${'%' + symbol + '%'}
       ${project_id !== undefined ? query`AND project_id = ${project_id}` : query``}
       ${filename !== undefined ? query`AND filename = ${filename}` : query``}
       ${type !== undefined ? query`AND type = ${type}` : query``}
     ORDER BY sim DESC
     LIMIT ${limit}
    `;
};

export {
  insert_or_update_entity,
  entity_search,
  get_entity,
  get_entity_by_id,
  get_entity_symbols,
  get_function_counts
};
</file>

<file path="model/project.mjs">
'use strict';

import { query } from '../db.mjs';

const insert_or_update_project = async (project) => {
  try {
    const ret = await query`
    INSERT INTO project (
      path,
      name,
      created_at
    ) VALUES (
      ${project.path},
      ${project.name},
      CURRENT_TIMESTAMP
    ) ON CONFLICT (name) DO UPDATE SET
      updated_at = CURRENT_TIMESTAMP
      RETURNING *
    `;

    return ret;
  } catch (error) {
    console.error(error);
    throw error;
  }
};

const get_project_by_name = async ({ name }) => {
  return await query`
    SELECT *
      FROM project
     WHERE name = ${name}
     ORDER BY name, path
    `;
};

const get_project_by_path = async ({ path }) => {
  return await query`
    SELECT *
      FROM project
     WHERE path = ${path}
     ORDER BY name, path
    `;
};

const get_project_by_id = async (id) => {
  const projects = await query`
    SELECT *
      FROM project
     WHERE id = ${id}
    `;

  return projects[0];
};

const get_all_projects_with_metadata = async () => {
  const results = await query`
    SELECT *
      FROM project_stats
    `;

  return results;
};

const refresh_project_stats = async () => {
  await query`
    REFRESH MATERIALIZED VIEW project_stats;
  `;
};

export {
  insert_or_update_project,
  get_project_by_name,
  get_project_by_path,
  get_project_by_id,
  get_all_projects_with_metadata,
  refresh_project_stats
};
</file>

<file path="model/relationship.mjs">
'use strict';

import { query } from '../db.mjs';
import { get_entity, get_entity_by_id } from './entity.mjs';

const insert_relationship = async (relationship) => {
  return await query`
    INSERT INTO relationship (
      caller,
      callee,
      line,
      comment
    ) VALUES (
      ${relationship.caller},
      ${relationship.callee},
      ${relationship.line},
      ${relationship.comment ? relationship.comment : null}
    )
    `;
};

const get_entities_by_caller_id = async ({ symbol, project_id }) => {
  const node = {};

  const entities = await query`
    SELECT
      c.filename               AS caller_filename,
      r.comment                AS relationship_comment,
      r.line                   AS relationship_line,

      e.id                     AS callee_id,
      e.project_id             AS callee_project_id,
      e.language               AS callee_language,
      e.symbol                 AS callee_symbol,
      e.type                   AS callee_type,
      e.filename               AS callee_filename,
      e.source                 AS callee_source,
      e.start_line             AS callee_start_line,
      e.end_line               AS callee_end_line,
      e.parameters             AS callee_parameters,
      e.comment                AS callee_comment,
      e.return_type            AS callee_return_type,
      e.created_at             AS callee_created_at,
      e.updated_at             AS callee_updated_at

    FROM relationship r
    JOIN entity c ON r.caller = c.id
    JOIN entity e ON r.callee = e.id
    WHERE c.symbol = ${symbol}
    ${project_id !== undefined ? query`AND e.project_id = ${project_id}` : query``}
  `;

  return entities;
};

const get_entities_by_callee_id = async ({ symbol, project_id }) => {
  const node = {};

  const entities = await query`
    SELECT
      c.filename               AS callee_filename,
      c.start_line             AS callee_start_line,
      r.comment                AS relationship_comment,
      r.line                   AS relationship_line,

      e.id                     AS caller_id,
      e.project_id             AS caller_project_id,
      e.language               AS caller_language,
      e.symbol                 AS caller_symbol,
      e.type                   AS caller_type,
      e.filename               AS caller_filename,
      e.source                 AS caller_source,
      e.start_line             AS caller_start_line,
      e.end_line               AS caller_end_line,
      e.parameters             AS caller_parameters,
      e.comment                AS caller_comment,
      e.return_type            AS caller_return_type,
      e.created_at             AS caller_created_at,
      e.updated_at             AS caller_updated_at

    FROM relationship r
    JOIN entity c ON r.callee = c.id
    JOIN entity e ON r.caller = e.id
    WHERE c.symbol = ${symbol}
    ${project_id !== undefined ? query`AND e.project_id = ${project_id}` : query``}
  `;

  return entities;
};

const clear_relationships_for_project = async (project) => {
  await query`
    DELETE FROM relationship WHERE caller IN (
      SELECT id FROM entity WHERE project_id = ${project.id}
    )`;
};

const build_call_tree = async (entity, visited = {}) => {
  if (visited[entity.id]) {
    return { children: [], node: entity, loop: true };
  }

  visited[entity.id] = true;

  const called_entities = await get_entities_by_caller_id(entity.id);

  const graph = { children: [], node: entity };
  for (const called_entity of called_entities) {
    graph.children.push(await build_call_tree(called_entity, visited));
  }

  return graph;
};

const call_graph_from_entity = async ({ project, entity }, visited = {}) => {
  if (visited[entity.id]) {
    return { children: [], node: entity, loop: true };
  }
  visited[entity.id] = true;

  const called_entities = await get_entities_by_caller_id(entity.id);

  const graph = { children: [], node: entity };
  for (const { called_entity } of called_entities) {
    graph.children.push(
      await graph_from_project_and_symbol({ project, symbol })
    );
  }

  return graph;
};

export {
  build_call_tree,
  insert_relationship,
  clear_relationships_for_project,
  call_graph_from_entity,
  get_entities_by_caller_id,
  get_entities_by_callee_id
};
</file>

<file path="model/sourcecode.mjs">
'use strict';

import { query } from '../db.mjs';

// TODO: change the field `path` to `filename`.
const insert_or_update_sourcecode = async (sourcecode) => {
  try {
    const ret = await query`
    INSERT INTO sourcecode (
      project_id,
      filename,
      source,
      created_at
    ) VALUES (
      ${sourcecode.project_id},
      ${sourcecode.filename},
      ${sourcecode.source},
      CURRENT_TIMESTAMP
    ) ON CONFLICT (project_id, filename) DO UPDATE SET
      source = ${sourcecode.source},
      updated_at = CURRENT_TIMESTAMP
      RETURNING *
    `;

    return ret;
  } catch (error) {
    console.error(error);
    throw error;
  }
};

const get_sourcecode = async ({ project_id, filename }) => {
  return await query`
    SELECT *
      FROM sourcecode
     WHERE project_id = ${project_id}
       AND filename = ${filename}
    `;
};

export { insert_or_update_sourcecode, get_sourcecode };
</file>

<file path="db.mjs">
'use strict';

import postgres from 'postgres';

import config from '../config.json' with { type: 'json' };

const query = postgres({
  user: config.database.username,
  password: config.database.password,
  database: config.database.database,
  host: config.database.hostname
});

export { query };
</file>

<file path="functions.mjs">
'use strict';

import { readFile } from 'fs/promises';
import { promisify } from 'util';
import { exec as child_exec } from 'child_process';
import { text_at_position } from './sourcecode.mjs';

const exec = promisify(child_exec);

import Parser from 'tree-sitter';
import C from 'tree-sitter-c';

const get_nodes_from_source = (
  source,
  filename,
  types = [
    'call_expression',
    'comment',
    'function_definition',
    'function_declarator',
    'primitive_type',
    'parameter_declaration',
    'parameter_list'
  ]
) => {
  const result = {};

  const tree = create_tree(source);

  for (const type of types) {
    result[type] = [];
  }

  let visited_children = false;
  let cursor = tree.walk();

  while (true) {
    if (!visited_children) {
      const node = cursor.currentNode;
      const idx = types.indexOf(node.type);
      if (idx !== -1) {
        result[types[idx]].push({
          content: text_at_position({
            source,
            start_line: node.startPosition.row + 1,
            end_line: node.endPosition.row + 1,
            start_position: node.startPosition.column,
            end_position: node.endPosition.column
          }),
          start_line: node.startPosition.row + 1,
          end_line: node.endPosition.row + 1,
          start_position: node.startPosition.column,
          end_position: node.endPosition.column,
          type: node.type,
          filename
        });
      }

      if (!cursor.gotoFirstChild()) {
        visited_children = true;
      }
    } else if (cursor.gotoNextSibling()) {
      visited_children = false;
    } else if (!cursor.gotoParent()) {
      break;
    }
  }
  return result;
};

const create_tree = (code) => {
  const parser = new Parser();
  parser.setLanguage(C);

  const tree = parser.parse(code);

  return tree;
};

const get_types_from_tree = (tree) => {
  const result = {};

  const types = {};
  let visited_children = false;
  let cursor = tree.walk();

  while (true) {
    if (!visited_children) {
      result[cursor.currentNode.type] = true;

      if (!cursor.gotoFirstChild()) {
        visited_children = true;
      }
    } else if (cursor.gotoNextSibling()) {
      visited_children = false;
    } else if (!cursor.gotoParent()) {
      break;
    }
  }
  return Object.keys(result);
};

// TODO: These need to support filename.
const get_comment_from_position = (entities, { start_line }) => {
  for (const entity of entities) {
    if (entity.end_line === start_line - 1) {
      return entity;
    }
  }
};

const get_source_from_position = (entities, { start_line }) => {
  for (const entity of entities) {
    if (entity.start_line === start_line) {
      return entity;
    }
  }
};

const get_parameters_from_position = (entities, { start_line, end_line }) => {
  for (const entity of entities) {
    if (entity.start_line <= start_line && entity.end_line >= end_line) {
      return entity;
    }
  }
};

const get_type_from_position = (entities, { start_line }) => {
  for (const entity of entities) {
    if (entity.start_line === start_line) {
      return entity;
    }
  }
};

export {
  create_tree,
  get_nodes_from_source,
  get_types_from_tree,
  get_source_from_position,
  get_parameters_from_position,
  get_type_from_position
};
</file>

<file path="project.mjs">
'use strict';

import {
  insert_or_update_project,
  get_project_by_name,
  get_project_by_path,
  refresh_project_stats
} from './model/project.mjs';
import { get_all_filenames_with_type, import_file } from './sourcecode.mjs';
import { get_nodes_from_source } from './functions.mjs';
import { insert_or_update_entity, get_entity } from './model/entity.mjs';
import { insert_or_update_sourcecode } from './model/sourcecode.mjs';
import {
  insert_relationship,
  clear_relationships_for_project
} from './model/relationship.mjs';

const get_types_from_tree = (tree) => {
  const result = {};

  const types = {};
  let visited_children = false;
  let cursor = tree.walk();

  while (true) {
    if (!visited_children) {
      result[cursor.currentNode.type] = true;

      if (!cursor.gotoFirstChild()) {
        visited_children = true;
      }
    } else if (cursor.gotoNextSibling()) {
      visited_children = false;
    } else if (!cursor.gotoParent()) {
      break;
    }
  }

  return Object.keys(result);
};

const find_caller = (entities, { project_id, line, filename, symbol }) => {
  for (const entity of entities) {
    if (
      symbol !== entity.symbol &&
      entity.start_line <= line &&
      entity.end_line >= line &&
      (filename ? filename === entity.filename : true)
    ) {
      return entity;
    }
  }
};

// Find a comment entity for the given line and file.
const get_comment = (entities, { start_line, filename, symbol }) => {
  for (const entity of entities) {
    if (
      entity.end_line === start_line - 1 &&
      (filename ? filename === entity.filename : true)
    ) {
      return entity;
    }
  }
};

const get_source = (entities, { start_line, filename }) => {
  for (const entity of entities) {
    if (
      entity.start_line === start_line &&
      (filename ? filename === entity.filename : true)
    ) {
      return entity;
    }
  }
};

const get_parameters = (entities, { start_line, end_line, filename }) => {
  for (const entity of entities) {
    if (
      entity.start_line <= start_line &&
      end_line >= entity.end_line &&
      (filename ? filename === entity.filename : true)
    ) {
      return entity;
    }
  }
};

const get_type = (entities, { start_line, filename }) => {
  for (const entity of entities) {
    if (
      entity.start_line === start_line &&
      (filename ? filename === entity.filename : true)
    ) {
      return entity;
    }
  }
};

const create_relationships_for_entities = async ({
  project_id,
  known_entities,
  entities,
  comments
}) => {
  // Iterate through the call_expressions.
  for (const entity of entities) {
    let callee;
    try {
      // Get the callee symbol without parentheses.
      callee = entity.content.substring(0, entity.content.indexOf('('));

      // Attempt to find the caller in our known entities.
      const caller = find_caller(Object.values(known_entities), {
        project_id,
        line: entity.start_line,
        symbol: callee,
        filename: entity.filename
      });

      // No caller in our known entities, weird.
      if (!caller) {
        continue;
      }

      // Find the callee entity.
      let callee_entity = known_entities[callee];

      // If we do not know about the entity, try to retrieve it from the project.
      if (!callee_entity) {
        const callees = await get_entity({ project_id, symbol: callee });
        if (callees.length > 0) {
          callee_entity = callees[0];
        }
      }

      // If we still do not know about the entity, try to retrieve it without a project.
      if (!callee_entity) {
        const callees = await get_entity({ symbol: callee });
        if (callees.length > 0) {
          callee_entity = callees[0];
        }
      }

      // If we still don't have one, then continue on.
      if (!callee_entity) {
        // Likely a function we don't know about, ok.
        continue;
      }

      // Set up the known entity.
      known_entities[callee] = callee_entity;

      // Find a comment if there is one.
      const comment = get_comment(comments, {
        start_line: entity.start_line,
        filename: entity.filename,
        symbol: callee
      });

      // And add the relationship for this entity couplet.
      await insert_relationship({
        callee: callee_entity.id,
        caller: caller.id,
        line: entity.start_line,
        comment: comment ? comment.content : null
      });
    } catch (error) {
      console.error(`Error processing function ${callee}: ${error.message}`);
      throw error;
    }
  }
};

const create_entities_for_nodes = async ({
  project_id,
  nodes,
  filename,
  language,
  known_entities,
  source
}) => {
  //console.log(JSON.stringify(nodes.parameter_list, null, 2));
  // Iterate through the entities for functions.
  for (const entity of nodes.function_definition) {
    // Get the function name.
    const name_parts = entity.content
      .substring(0, entity.content.indexOf('('))
      .replace(/\s+/g, ' ')
      .replace(/\*/g, '')
      .split(' ');
    const name = name_parts[name_parts.length - 1].trim();

    // And create a default entity.
    const new_entity = {
      project_id,
      symbol: name,
      type: 'function',
      language,
      filename,
      start_line: entity.start_line,
      end_line: entity.end_line,
      start_position: entity.start_position,
      end_position: entity.end_position,
      parameters: null,
      source: null,
      comment: null,
      return_type: 'void'
    };

    // Get a copy of the comment if there is one.
    const comment_entity = get_comment(nodes.comment, {
      symbol: new_entity.symbol,
      start_line: new_entity.start_line,
      filename
    });

    if (comment_entity) {
      new_entity.comment = comment_entity.content;
    }

    // Get a copy of the source code.
    const source_entity = get_source(nodes.function_definition, {
      start_line: new_entity.start_line,
      end_line: new_entity.end_line,
      filename
    });

    if (source_entity) {
      new_entity.source = source_entity.content;
    }

    // Get a copy of the parameters.
    const parameters_entity = get_parameters(nodes.parameter_list, {
      start_line: new_entity.start_line,
      end_line: new_entity.end_line,
      filename
    });
    //console.log(parameters_entity);
    if (parameters_entity) {
      new_entity.parameters = parameters_entity.content.replace(/\s+/g, ' ');
    }

    // Get the return type.
    const type = get_type(nodes.primitive_type, {
      start_line: new_entity.start_line,
      filename: new_entity.filename
    });

    if (type) {
      new_entity.return_type = type.content;
    }

    // Insert the new entity into the database.
    const res = await insert_or_update_entity(new_entity);

    // Stash a copy of the entity.
    known_entities[new_entity.symbol] = res[0];
  }
};

const create_project = async ({ name, path }) => {
  // Check to see if there is a project by this name already.
  let projects = await get_project_by_name({ name });
  if (projects.length) {
    throw new Error(`Project '${name}' already exists.`);
  }

  // Check to see if there is a project with this path already.
  projects = await get_project_by_path({ path });
  if (projects.length) {
    throw new Error(`Project '${path}' already exists.`);
  }

  await create_or_update_project({ name, path });

  return await refresh_project_stats();
};

const refresh_project = async ({ name }) => {
  // Check to see if there is a project by this name already.
  let projects = await get_project_by_name({ name });
  if (!projects.length) {
    throw new Error(`Project '${name}' does not exist.`);
  }

  await create_or_update_project({ name, path: projects[0].path });

  return await refresh_project_stats();
};

const create_or_update_project = async ({ name, path }) => {
  // Set up our known entities.
  const known_entities = {};

  // Set up our functions calls for later.
  const function_calls = [];

  // And our comments.
  const comments = [];

  // Get a copy of our CWD so we can come back to it later.
  const cwd = process.cwd();

  // Change directory to the project path.
  process.chdir(path);

  // Get a copy of all .c and .h files.
  const files = await get_all_filenames_with_type('.', 'c');
  //files.push(...(await get_all_filenames_with_type('.', 'h')));

  if (files.length === 0) {
    throw new Error('No source files found.');
  }

  // Create the project.
  const project = await insert_or_update_project({ name, path });

  // Iterate through the files.
  for (const filename of files) {
    // Read the file content.
    const source = await import_file(filename);

    // Write it to the database.
    await insert_or_update_sourcecode({
      project_id: project[0].id,
      filename,
      source
    });

    // Get a copy of the tree nodes to work from.
    const nodes = get_nodes_from_source(source, filename);

    // Save a copy of our function calls.
    function_calls.push(...nodes.call_expression);

    // Save a copy of our comments.
    comments.push(...nodes.comment);

    // Create this file's entities.
    await create_entities_for_nodes({
      source,
      project_id: project[0].id,
      nodes,
      filename,
      language: 'c',
      known_entities
    });
  }

  // Clear the relationships before repopulating them.
  await clear_relationships_for_project(project[0]);

  // Now create the relationsips for all known calls.
  await create_relationships_for_entities({
    project_id: project[0].id,
    entities: function_calls,
    known_entities,
    comments
  });

  process.chdir(cwd);
};

export { create_project, refresh_project, get_types_from_tree };
</file>

<file path="search.mjs">
'use strict';

export { search_tree };

/**
 * Search the BST for nodes matching multiple criteria.
 *
 * `criteria` is an object where each key is a field name
 * (`filename`, `start_line`, `end_line`) and the value is an
 * object of the form `{ value, op }`.
 *
 * Supported operators (default is `'eq'` if omitted):
 *   - 'eq'  (equals)
 *   - 'gte' (>=)
 *   - 'lte' (<=)
 *   - 'gt'  (>)
 *   - 'lt'  ( < )
 *
 * @param {TreeNode|null} root
 * @param {Object} criteria
 * @returns {Array<Object>} matching nodes
 */
function search_tree(root, criteria) {
  const results = [];
  if (!root) return results;

  // Pre‑process criteria: ensure every entry has an op and a value.
  const processed = Object.entries(criteria).map(([field, spec]) => {
    const value = spec.value !== undefined ? spec.value : spec; // support shorthand {field: value}
    const op = spec.op || 'eq';
    return { field, value, op };
  });

  function matches(node) {
    for (const { field, value, op } of processed) {
      const nodeVal = node[field];
      switch (op) {
        case 'eq':
          if (nodeVal !== value) return false;
          break;
        case 'gte':
          if (nodeVal < value) return false;
          break;
        case 'lte':
          if (nodeVal > value) return false;
          break;
        case 'gt':
          if (nodeVal <= value) return false;
          break;
        case 'lt':
          if (nodeVal >= value) return false;
          break;
        default:
          return false; // unknown operator
      }
    }
    return true;
  }

  // Simple DFS: all nodes could potentially match; pruning is omitted for clarity.
  function traverse(node) {
    if (!node) return;
    if (matches(node.node)) results.push(node.node);
    traverse(node.left);
    traverse(node.right);
  }

  traverse(root);
  return results;
}
</file>

<file path="sourcecode.mjs">
'use strict';

import { readdir, readFile, stat } from 'fs/promises';
import path from 'path';

const import_file = async (path) => {
  try {
    const content = await readFile(path, 'utf8');
    content.replace(/\\/g, '\\\\');

    return content;
  } catch (error) {
    throw error;
  }
};

const text_at_position = ({
  source,
  start_line,
  start_position,
  end_line,
  end_position
}) => {
  // Make a copy of the source as lines.
  const lines = source.split('\n');

  // Check for any undefined values and set some defaults.
  if (start_line === undefined) {
    start_line = 0;
  } else {
    // Otherwise we decrement the line since we are 0 based.
    start_line--;
  }

  if (end_line === undefined) {
    end_line = lines.length;
  } else {
    end_line--;
  }

  if (start_position === undefined) {
    start_position = 0;
  }

  if (end_position === undefined) {
    end_position = -1;
  }

  const parts = [];

  for (
    let current_line = start_line;
    current_line <= end_line;
    current_line++
  ) {
    // If we are on the first line matched, we get a partial line.
    if (current_line === start_line) {
      // If the end line is the same as the start line, we get a partial
      // from the start position to the end position.
      if (end_line === start_line) {
        if (end_position === -1) {
          end_position = lines[current_line].length;
        }
        parts.push(lines[current_line].substring(start_position, end_position));
      } else {
        parts.push(lines[current_line].substring(start_position));
      }
    } else if (current_line === end_line) {
      // When -1 is passed as the end_position, assume it's the whole line.
      if (end_position === -1) {
        if (lines[current_line] === undefined) {
          break;
        }

        end_position = lines[current_line].length;
      }

      parts.push(lines[current_line].substring(0, end_position));
    } else {
      parts.push(lines[current_line]);
    }
  }

  return parts.join('\n');
};

// Get all files of a type from a directory recursively.
const get_all_filenames_with_type = async (directory, type) => {
  const files = [];

  const files_in_directory = await readdir(directory);
  for (const file of files_in_directory) {
    const absolute = path.join(directory, file);
    const stats = await stat(absolute);

    if (stats.isDirectory()) {
      files.push(...(await get_all_filenames_with_type(absolute, type)));
    } else {
      files.push(absolute);
    }
  }

  return files.filter((file) => file.endsWith(`.${type}`));
};

export { import_file, text_at_position, get_all_filenames_with_type };
</file>

<file path="strings.mjs">
'use strict';

// String representations for tool calls.
const tools = {
  function_list: {
    name: 'function_list',
    description: `Lists all functions, filtered by project.

    The returned JSON will be in the following format:

    {
      "$schema": "http://json-schema.org/draft-04/schema#",
      "description": "function",
      "type": "object",
      "properties": {
        "id": {
          "type": "number",
          "description": "The unique identifier of the entity"
        },
        "project": {
          "type": "string",
          "minLength": 1,
          "description": "The project name"
        },
        "language": {
          "type": "string",
          "minLength": 1,
          "description": "The language of the function"
        },
        "symbol": {
          "type": "string",
          "minLength": 1,
          "description": "The symbol name of the function"
        },
        "type": {
          "type": "string",
          "minLength": 1,
          "description": "The type of the symbol, function or class"
        },
        "filename": {
          "type": "string",
          "minLength": 1,
          "description": "The filename the function is defined in"
        },
        "start_line": {
          "type": "number"
        },
        "end_line": {
          "type": "number"
        },
        "parameters": {
          "type": "string",
          "minLength": 1
        },
        "comment": {
          "type": "string",
          "description": "The comment for the entity"
        },
        "returns": {
          "type": "string",
          "minLength": 1,
          "description": "The return type of the function"
        },
        "created_at": {
          "type": "string",
          "minLength": 1
        },
        "updated_at": {
          "type": "string",
          "minLength": 1
        }
      },
      "required": [
        "id",
        "project",
        "language",
        "symbol",
        "type",
        "filename",
        "start_line",
        "end_line",
        "parameters",
        "returns",
        "created_at"
      ]
    }`
  },
  function_search: {
    name: `function_search`,
    description: `Searches for a function by name.  Partial matches will be returned, and the
    search is case-insensitive.  Results are sorted by relevance and then by name.

    The returned JSON will be in the following format:

    {
      "$schema": "http://json-schema.org/draft-04/schema#",
      "description": "function",
      "type": "object",
      "properties": {
        "id": {
          "type": "number",
          "description": "The unique identifier of the entity"
        },
        "project": {
          "type": "string",
          "minLength": 1,
          "description": "The project name"
        },
        "language": {
          "type": "string",
          "minLength": 1,
          "description": "The language of the function"
        },
        "symbol": {
          "type": "string",
          "minLength": 1,
          "description": "The symbol name of the function"
        },
        "type": {
          "type": "string",
          "minLength": 1,
          "description": "The type of the symbol, function or class"
        },
        "filename": {
          "type": "string",
          "minLength": 1,
          "description": "The filename the function is defined in"
        },
        "start_line": {
          "type": "number"
        },
        "end_line": {
          "type": "number"
        },
        "parameters": {
          "type": "string",
          "minLength": 1
        },
        "comment": {
          "type": "string",
          "description": "The comment for the entity"
        },
        "returns": {
          "type": "string",
          "minLength": 1,
          "description": "The return type of the function"
        },
        "created_at": {
          "type": "string",
          "minLength": 1
        },
        "updated_at": {
          "type": "string",
          "minLength": 1
        }
      },
      "required": [
        "id",
        "project",
        "language",
        "symbol",
        "type",
        "filename",
        "start_line",
        "end_line",
        "parameters",
        "returns",
        "created_at"
      ]
    }`
  },
  function_retrieve: {
    name: 'function_retrieve',
    description: `Retrieves an function from the code knowledge graph.
     This tool is useful for retrieving functions from the code knowledge graph.
     It takes a symbol name (function name) as input and returns the function
     information.  The  entity information includes the function's name (symbol), type, location
     in the code, and the source of the function.  The function information is returned
     as a JSON object.  If more than one function matches the input, the tool will return
     all matching functions.  You can also specify the project to only return functions
     from that project, as well as the type of symbol to retrieve (function name).

     The returned JSON will be in the following format:

     {
       "$schema": "http://json-schema.org/draft-04/schema#",
       "description": "function",
       "type": "object",
       "properties": {
         "id": {
           "type": "number",
           "description": "The unique identifier of the entity"
         },
         "project": {
           "type": "string",
           "minLength": 1,
           "description": "The project name"
         },
         "language": {
           "type": "string",
           "minLength": 1,
           "description": "The language of the function"
         },
         "symbol": {
           "type": "string",
           "minLength": 1,
           "description": "The symbol name of the function"
         },
         "type": {
           "type": "string",
           "minLength": 1,
           "description": "The type of the symbol, function or class"
         },
         "filename": {
           "type": "string",
           "minLength": 1,
           "description": "The filename the function is defined in"
         },
         "start_line": {
           "type": "number"
         },
         "end_line": {
           "type": "number"
         },
         "parameters": {
           "type": "string",
           "minLength": 1
         },
         "comment": {
           "type": "string",
           "description": "The comment for the entity"
         },
         "returns": {
           "type": "string",
           "minLength": 1,
           "description": "The return type of the function"
         },
         "source": {
           "type": "string",
           "description": "The source code of the function"
         },
         "created_at": {
           "type": "string",
           "minLength": 1
         },
         "updated_at": {
           "type": "string",
           "minLength": 1
         }
       },
       "required": [
         "id",
         "project",
         "language",
         "symbol",
         "type",
         "filename",
         "start_line",
         "end_line",
         "created_at"
       ]
     }
    `
  },
  generate_call_tree: {
    name: 'generate_call_tree',
    description: `Generates a call tree of code through all known projects, with the
     root of the tree being the specified symbol (always a function).  The resulting
     data structure will be a JSON object representing the call tree.  Each object of
     the tree will have a node containing the project, language symbol, filename,
     start_line, end_line, and child nodes representing the called symbols (functions).

     The returned JSON will be of the following format:

     {
       "$schema": "http://json-schema.org/draft-04/schema#",
       "description": "A call tree representing function calls made from a function.  The node is the entity, each entry in children represents an additional call tree.  If there is a loop, then loop is set to true and no children are appended.",
       "id": "call_tree",
       "type": "object",
       "properties": {
         "node": {
           "type": "object",
           "properties": {
             "id": {
               "type": "number",
               "description": "The unique identifier of the node"
             },
             "project": {
               "type": "string",
               "minLength": 1,
               "description": "The project name"
             },
             "language": {
               "type": "string",
               "minLength": 1,
               "description": "The language of the function"
             },
             "symbol": {
               "type": "string",
               "minLength": 1,
               "description": "The symbol name of the function"
             },
             "type": {
               "type": "string",
               "minLength": 1,
               "description": "The type of the symbol, function or class"
             },
             "filename": {
               "type": "string",
               "minLength": 1,
               "description": "The filename the function is defined in"
             },
             "start_line": {
               "type": "number"
             },
             "end_line": {
               "type": "number"
             },
             "parameters": {
               "type": "string",
               "minLength": 1
             },
             "comment": {
               "type": "string",
               "description": "The comment for the entity"
             },
             "returns": {
               "type": "string",
               "minLength": 1,
               "description": "The return type of the function"
             },
             "created_at": {
               "type": "string",
               "minLength": 1
             },
             "updated_at": {
               "type": "string",
               "minLength": 1
             }
           },
           "required": [
             "id",
             "project",
             "language",
             "symbol",
             "type",
             "filename",
             "start_line",
             "end_line",
             "created_at"
           ]
         },
         "loop": {
           "type": "boolean",
           "description": "Whether this symbol having children would cause an infinite loop"
         },
         "children": {
           "type": "array",
           "items": {
             "$ref": "#"
           }
         }
       },
       "required": [
         "node",
         "children"
       ]
     }`
  },
  function_callees: {
    name: 'function_callees',
    description: `Retrieves one or more functions that are called by the function passed in.

     The returned JSON will be in the following format:

     {
       "$schema": "http://json-schema.org/draft-04/schema#",
       "description": "function",
       "type": "object",
       "properties": {
         "id": {
           "type": "number",
           "description": "The unique identifier of the entity"
         },
         "project": {
           "type": "string",
           "minLength": 1,
           "description": "The project name"
         },
         "language": {
           "type": "string",
           "minLength": 1,
           "description": "The language of the function"
         },
         "symbol": {
           "type": "string",
           "minLength": 1,
           "description": "The symbol name of the function"
         },
         "type": {
           "type": "string",
           "minLength": 1,
           "description": "The type of the symbol, function or class"
         },
         "filename": {
           "type": "string",
           "minLength": 1,
           "description": "The filename the function is defined in"
         },
         "start_line": {
           "type": "number"
         },
         "end_line": {
           "type": "number"
         },
         "parameters": {
           "type": "string",
           "minLength": 1
         },
         "comment": {
           "type": "string",
           "description": "The comment for the entity"
         },
         "returns": {
           "type": "string",
           "minLength": 1,
           "description": "The return type of the function"
         },
         "created_at": {
           "type": "string",
           "minLength": 1
         },
         "updated_at": {
           "type": "string",
           "minLength": 1
         }
       },
       "required": [
         "id",
         "project",
         "language",
         "symbol",
         "type",
         "filename",
         "start_line",
         "end_line",
         "parameters",
         "returns",
         "created_at"
       ]
     }`
  },
  function_callers: {
    name: 'function_callers',
    description: `Retrieves one or more functions that are called by the function passed in.

     The returned JSON will be in the following format:

     {
       "$schema": "http://json-schema.org/draft-04/schema#",
       "description": "function",
       "type": "object",
       "properties": {
         "id": {
           "type": "number",
           "description": "The unique identifier of the entity"
         },
         "project": {
           "type": "string",
           "minLength": 1,
           "description": "The project name"
         },
         "language": {
           "type": "string",
           "minLength": 1,
           "description": "The language of the function"
         },
         "symbol": {
           "type": "string",
           "minLength": 1,
           "description": "The symbol name of the function"
         },
         "type": {
           "type": "string",
           "minLength": 1,
           "description": "The type of the symbol, function or class"
         },
         "filename": {
           "type": "string",
           "minLength": 1,
           "description": "The filename the function is defined in"
         },
         "start_line": {
           "type": "number"
         },
         "end_line": {
           "type": "number"
         },
         "parameters": {
           "type": "string",
           "minLength": 1
         },
         "comment": {
           "type": "string",
           "description": "The comment for the entity"
         },
         "returns": {
           "type": "string",
           "minLength": 1,
           "description": "The return type of the function"
         },
         "created_at": {
           "type": "string",
           "minLength": 1
         },
         "updated_at": {
           "type": "string",
           "minLength": 1
         }
       },
       "required": [
         "id",
         "project",
         "language",
         "symbol",
         "type",
         "filename",
         "start_line",
         "end_line",
         "parameters",
         "returns",
         "created_at"
       ]
     }`
  },
  project_list: {
    name: 'project_list',
    description: `Lists projects available to the user.  A project name can be used as an argument
    to retrieve functions and information about source code.

     The returned JSON will be in the following format:

     {
       "$schema": "http://json-schema.org/draft-04/schema#",
       "description": "Code Projects",
       "type": "object",
       "properties": {
         "id": {
           "type": "number",
           "description": "Unique identifier for the project"
         },
         "name": {
           "type": "string",
           "minLength": 1,
           "description": "Name of the project"
         },
         "path": {
           "type": "string",
           "minLength": 1,
           "description": "Path to the project"
         },
         "created_at": {
           "type": "string",
           "minLength": 1,
           "description": "Date and time when the project was created"
         },
         "updated_at": {
           "type": "string",
           "minLength": 1,
           "description": "Date and time when the project was last updated"
         },
         "file_count": {
           "type": "number",
           "description": "Number of files in the project"
         },
         "entity_count": {
           "type": "number",
           "description": "Number of entities in the project"
         }
       },
       "required": [
         "id",
         "name",
         "path",
         "created_at",
         "updated_at",
         "file_count",
         "entity_count"
       ]
     }`
  },
  project_info: {
    name: 'project_info',
    description: `Returns information about a project.`,
    parameters: {
      id: {
        type: 'string',
        description: 'ID of the project'
      }
    },
    response: {
      type: 'object',
      properties: {
        id: {
          type: 'string',
          description: 'ID of the project'
        },
        name: {
          type: 'string',
          description: 'Name of the project'
        },
        path: {
          type: 'string',
          description: 'Path of the project'
        },
        created_at: {
          type: 'string',
          description: 'Date and time the project was created'
        },
        updated_at: {
          type: 'string',
          description: 'Date and time the project was last updated'
        },
        file_count: {
          type: 'number',
          description: 'Number of files in the project'
        },
        entity_count: {
          type: 'number',
          description: 'Number of entities in the project'
        }
      }
    },
    required: ['id']
  },
  read_sourcecode: {
    name: 'read_sourcecode',
    description: `Returns a copy of the source code for a \`filename\` in a project.  This
     tool can return both any part of a file, including the whole file, or when given
     \`start_line\` and \`end_line\` a \`function\` or \`comment\` can be retrieved.

     If \`start_line\` is provided, the source code will be returned from that line to the
     end of the file, otherwise the \`start_line\` will be the first line of the file if
     not provided.  If you wish to start at the first line of the file, you can provide
     \`start_line: 1\`.

     If \`end_line\` is provided, the source code will be returned from the \`start_line\`
     to the \`end_line\`, otherwise the \`end_line\` will be last line of the file if not
     provided.  If you wish to retrieve the the end of the file, you can also provide
     \`end_line\: -1\`, which is the default behavior if not provided.

     If \`start_position\` is provided, the source code will be returned from that
     position in the line.  If it is not provided, it will default to \`0\` or the
     start of the line.

     If \`end_position\` is provided, the source code will be returned from the
     \`start_position\` (or \`0\` if not provided) to the \`end_position\`.  If no
     \`end_position\` is provided, it will default to \`-1\`, which is the end of
     the line.`
  }
};

export { tools };
</file>

<file path="tree.mjs">
'use strict';

class TreeNode {
  constructor(node) {
    this.node = node; // the original data object
    this.left = null; // left child
    this.right = null; // right child
  }
}

/**
 * Canonical comparison key for a node.
 * Returns an array: [filename, start_line, end_line]
 */
function key(node) {
  return [node.filename, node.start_line, node.end_line];
}

/**
 * Compare two keys lexicographically.
 * Returns <0 if a<b, 0 if equal, >0 if a>b.
 */
function compare_keys(a, b) {
  if (a[0] < b[0]) return -1;
  if (a[0] > b[0]) return 1;
  if (a[1] < b[1]) return -1;
  if (a[1] > b[1]) return 1;
  if (a[2] < b[2]) return -1;
  if (a[2] > b[2]) return 1;
  return 0;
}

/**
 * Create an empty tree.
 */
function create_tree() {
  return null;
}

/**
 * Insert a node object into a tree.
 */
function insert_into_tree(root, nodeObj) {
  const newNode = new TreeNode(nodeObj);
  if (!root) return newNode;

  let current = root;
  while (true) {
    const comp = compare_keys(key(nodeObj), key(current.node));
    if (comp < 0) {
      if (!current.left) {
        current.left = newNode;
        break;
      }
      current = current.left;
    } else {
      if (!current.right) {
        current.right = newNode;
        break;
      }
      current = current.right;
    }
  }

  return root; // root unchanged
}

/**
 * Helper that creates a TreeNode from a plain object
 * (used by tests / fixtures).
 */
function node_from_obj(obj) {
  return new TreeNode(obj);
}

/**
 * Perform a preorder traversal and return an array of node objects
 * (the data objects, not TreeNode wrappers).
 */
function preorder_traversal(root) {
  const result = [];
  function dfs(node) {
    if (!node) return;
    result.push(node.node);
    dfs(node.left);
    dfs(node.right);
  }
  dfs(root);
  return result;
}

/**
 * Inorder traversal (useful for unit tests).
 */
function inorder_traversal(root) {
  const result = [];
  function dfs(node) {
    if (!node) return;
    dfs(node.left);
    result.push(node.node);
    dfs(node.right);
  }
  dfs(root);
  return result;
}

export {
  create_tree,
  insert_into_tree,
  node_from_obj,
  preorder_traversal,
  inorder_traversal
};
</file>

<file path="fixtures/tags.json">
{"_type": "tag", "name": "main", "path": "test.c", "pattern": "/^int main( ) {$/", "language": "C", "line": 11, "typeref": "typename:int", "kind": "function", "signature": "()", "roles": "def", "end": 16}
{"_type": "tag", "name": "my_function", "path": "test.c", "pattern": "/^void my_function(int arg) { printf(\"Hello, World! (%d)\\\\n\", arg); }$/", "language": "C", "line": 9, "typeref": "typename:void", "kind": "function", "signature": "(int arg)", "roles": "def", "end": 9}
</file>

<file path="fixtures/test.c">
#include <stdio.h>

void my_function(int);

struct {
  int x;
  int y;
} xy;

/**
 * @brief Function to be called.
 *
 * This function prints a greeting message along with the provided argument.
 * @param arg Argument to be passed to the function.
 */
void my_function(int arg) { printf("Hello, World! (%d)\n", arg); }

int main( ) {
  // Call the function with an argument
  my_function(42);

  return 0;
}
</file>

<file path="lib/file.mjs">
'use strict';

import {
  import_file,
  text_at_position,
  get_all_filenames_with_type
} from '../../lib/sourcecode.mjs';

import { test } from 'st';

await test('gets the correct content for a position across multiple lines', async (t) => {
  const source = await import_file('./tests/fixtures/test.c');

  const expected = `/**
 * @brief Function to be called.
 *
 * This function prints a greeting message along with the provided argument.
 * @param arg Argument to be passed to the function.
 */`;

  const text = text_at_position({
    source,
    start_line: 10,
    start_position: 0,
    end_line: 15,
    end_position: 3
  });
  t.assert.eq(text, expected, 'The text should match the expected content');
});

await test('gets the correct content for a position of one line', async (t) => {
  const source = await import_file('./tests/fixtures/test.c');

  const expected = `void my_function(int arg) { printf("Hello, World! (%d)\\n", arg); }`;

  const text = text_at_position({
    source,
    start_line: 16,
    start_position: 0,
    end_line: 16,
    end_position: -1
  });
  t.assert.eq(text, expected, 'The text should match the expected content');
});

await test('the full file is returned when only source is requested', async (t) => {
  const source = await import_file('./tests/fixtures/test.c');

  const text = text_at_position({
    source
  });
  t.assert.eq(text, source, 'The text should match the full source');
});

await test('all files of a type can be found from a directory', async (t) => {
  const files = await get_all_filenames_with_type('./tests/fixtures', 'c');

  t.assert.eq(
    files[0],
    'tests/fixtures/test.c',
    'The correct filename is found'
  );
});
</file>

<file path="lib/tree.mjs">
'use strict';

import { test } from 'st';
import {
  create_tree,
  insert_into_tree,
  preorder_traversal
} from '../../lib/tree.mjs';
import { search_tree } from '../../lib/search.mjs';

const sample = {
  content: 'Some content',
  start_line: 874,
  end_line: 1001,
  start_position: 0,
  end_position: 1,
  type: 'function_definition',
  filename: 'src/pljs.c'
};

const sample2 = {
  content: 'Other code',
  start_line: 200,
  end_line: 300,
  start_position: 10,
  end_position: 20,
  type: 'variable_declaration',
  filename: 'src/utils.c'
};

await test('tree insertion creates correct structure', async (t) => {
  let tree = create_tree();
  tree = insert_into_tree(tree, sample);
  tree = insert_into_tree(tree, sample2);

  const preorder = preorder_traversal(tree);
  t.assert.ok(preorder.length === 2, 'Two nodes inserted');
  t.assert.eq(preorder[0].filename, 'src/pljs.c', 'First by filename');
  t.assert.eq(preorder[1].filename, 'src/utils.c', 'Second by filename');
});

await test('search by exact filename', async (t) => {
  let tree = create_tree();
  tree = insert_into_tree(tree, sample);
  tree = insert_into_tree(tree, sample2);

  const results = search_tree(tree, {
    filename: { value: 'src/pljs.c', op: 'eq' }
  });
  t.assert.eq(results.length, 1, 'Found one node');
  t.assert.eq(results[0].start_line, 874, 'Correct node returned');
});

await test('search by start_line range (gte)', async (t) => {
  let tree = create_tree();
  tree = insert_into_tree(tree, sample);
  tree = insert_into_tree(tree, sample2);

  const results = search_tree(tree, { start_line: { value: 300, op: 'gte' } });
  t.assert.eq(results.length, 1, 'Only one node meets start_line >= 300');
  t.assert.eq(results[0].filename, 'src/pljs.c', 'Correct node returned');
});

await test('partial criteria search – filename only', async (t) => {
  let tree = create_tree();
  tree = insert_into_tree(tree, sample);
  tree = insert_into_tree(tree, sample2);

  const results = search_tree(tree, {
    filename: { value: 'src/utils.c', op: 'eq' }
  });
  t.assert.eq(results.length, 1);
  t.assert.eq(results[0].type, 'variable_declaration');
});

await test('search with lt operator', async (t) => {
  let tree = create_tree();
  tree = insert_into_tree(tree, sample);
  tree = insert_into_tree(tree, sample2);

  const results = search_tree(tree, { start_line: { value: 500, op: 'lt' } });
  t.assert.eq(results.length, 1, 'Only one node satisfies start_line < 500');
  t.assert.eq(results[0].filename, 'src/utils.c', 'Correct node returned');
});

/* ----------------------------------------------------
   New test: compound criteria
   ---------------------------------------------------- */
await test('search by multiple criteria (filename + ranges)', async (t) => {
  let tree = create_tree();
  tree = insert_into_tree(tree, sample);
  tree = insert_into_tree(tree, sample2);

  // Want nodes where:
  //   filename = 'src/pljs.c'
  //   start_line <= 1000
  //   end_line   >= 800
  const criteria = {
    filename: { value: 'src/pljs.c', op: 'eq' },
    start_line: { value: 1000, op: 'lte' },
    end_line: { value: 300, op: 'gte' }
  };

  const results = search_tree(tree, criteria);
  t.assert.eq(results.length, 1, 'Only the sample node matches all predicates');
  t.assert.eq(results[0].content, 'Some content', 'Sample content returned');
});
</file>

<file path="1753817175187-table_project.mjs">
'use strict';

import { query } from '../lib/db.mjs';

// Execute the migration.
const up = async () => {
  await query`
  CREATE TABLE project (
    id SERIAL PRIMARY KEY,
    path TEXT,
    name TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
    )`;
};

// Revert the migration.
const down = async () => {
  await query`DROP TABLE project`;
};

export { down, up };
</file>

<file path="1753817176438-table_entity.mjs">
'use strict';

import { query } from '../lib/db.mjs';

// Execute the migration.
const up = async () => {
  await query`
    CREATE TABLE entity (
      id SERIAL PRIMARY KEY,
      project_id INT NOT NULL REFERENCES project(id),
      language TEXT NOT NULL,
      symbol TEXT NOT NULL,
      type TEXT,
      filename TEXT,
      source TEXT,
      start_line INTEGER,
      end_line INTEGER,
      parameters TEXT,
      comment TEXT,
      return_type TEXT,
      created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
    )`;
};

// Revert the migration.
const down = async () => {
  await query`
   DROP TABLE entity
`;
};

export { down, up };
</file>

<file path="1753817876593-index_entity.mjs">
'use strict';

import { query } from '../lib/db.mjs';

// Execute the migration.
const up = async () => {
  await query`
    CREATE UNIQUE INDEX idx_entity_project_id_language_symbol_type_unique
      ON entity(project_id, language, symbol, type)
  `;
};

// Revert the migration.
const down = async () => {
  await query`
    DROP INDEX idx_entity_project_id_language_symbol_type_unique
  `;
};

export { down, up };
</file>

<file path="1753934080094-table_relationship.mjs">
'use strict';

import { query } from '../lib/db.mjs';

// Execute the migration.
const up = async () => {
  await query`
    CREATE TABLE relationship (
      id SERIAL PRIMARY KEY,
      caller INT NOT NULL REFERENCES entity(id),
      callee INT NOT NULL REFERENCES entity(id),
      line INT NOT NULL,
      comment TEXT
    )`;
};

// Revert the migration.
const down = async () => {
  await query`
   DROP TABLE relationship
`;
};

export { down, up };
</file>

<file path="1754286548294-index_relationship.mjs">
'use strict';

import { query } from '../lib/db.mjs';

// Execute the migration.
const up = async () => {
  await query`
    CREATE INDEX idx_relationship_caller
      ON relationship(caller) INCLUDE (callee)
  `;

  await query`
    CREATE INDEX idx_relationship_callee
      ON relationship(callee) INCLUDE (caller)
  `;
};

// Revert the migration.
const down = async () => {
  await query`
    DROP INDEX idx_relationship_caller
  `;

  await query`
    DROP INDEX idx_relationship_callee
  `;
};

export { down, up };
</file>

<file path="1754436391764-table_sourcecode.mjs">
'use strict';

import { query } from '../lib/db.mjs';

// Execute the migration.
const up = async () => {
  await query`
    CREATE TABLE sourcecode (
      id SERIAL PRIMARY KEY,
      project_id INT NOT NULL REFERENCES project(id),
      filename TEXT,
      source TEXT,
      created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
    )`;
};

// Revert the migration.
const down = async () => {
  await query`DROP TABLE sourcecode`;
};

export { down, up };
</file>

<file path="1754438557607-index_project.mjs">
'use strict';

import { query } from '../lib/db.mjs';

// Execute the migration.
const up = async () => {
  await query`
    CREATE UNIQUE INDEX idx_project_name_unique
      ON project(name)
  `;
};

// Revert the migration.
const down = async () => {
  await query`
    DROP INDEX idx_project_name_unique
  `;
};

export { down, up };
</file>

<file path="1754439911414-index_sourcecode.mjs">
'use strict';

import { query } from '../lib/db.mjs';

// Execute the migration.
const up = async () => {
  await query`
    CREATE UNIQUE INDEX idx_sourcecode_project_id_filename_unique
      ON sourcecode(project_id, filename)
  `;
};

// Revert the migration.
const down = async () => {
  await query`
    DROP INDEX idx_sourcecode_project_id_filename_unique
  `;
};

export { down, up };
</file>

<file path="1754516227541-index_sourcecode_project_id.mjs">
'use strict';

import { query } from '../lib/db.mjs';

// Execute the migration.
const up = async () => {
  await query`
    CREATE INDEX idx_sourcecode_project_id
      ON sourcecode(project_id)
  `;
};

// Revert the migration.
const down = async () => {
  await query`
    DROP INDEX idx_sourcecode_project_id
  `;
};

export { down, up };
</file>

<file path="1754516260587-index_entity_project_id.mjs">
'use strict';

import { query } from '../lib/db.mjs';

// Execute the migration.
const up = async () => {
  await query`
    CREATE INDEX idx_entity_project_id
      ON entity(project_id)
  `;
};

// Revert the migration.
const down = async () => {
  await query`
    DROP INDEX idx_entity_project_id
  `;
};

export { down, up };
</file>

<file path="1755887814675-matview_project_stats.mjs">
'use strict';

import { query } from '../lib/db.mjs';

// Execute the migration.
const up = async () => {
  await query`
    CREATE MATERIALIZED VIEW project_stats AS
      SELECT p.id AS project_id,
             p.name AS name,
             p.path AS path,
             p.created_at AS created_at,
             p.updated_at AS updated_at,
             COUNT(DISTINCT e.id) AS entity_count,
             COUNT(DISTINCT s.id) AS source_count
        FROM project p
        LEFT JOIN entity e ON p.id = e.project_id
        LEFT JOIN sourcecode s ON p.id = s.project_id
       GROUP BY p.id, p.name, p.path, p.created_at, p.updated_at
  `;
};

// Revert the migration.
const down = async () => {
  await query`
    DROP MATERIALIZED VIEW project_stats
  `;
};

export { down, up };
</file>

<file path="lib/functions.mjs">
'use strict';

import { create_tree, get_nodes_from_source } from '../../lib/functions.mjs';
import { import_file, text_at_position } from '../../lib/sourcecode.mjs';

import { test } from 'st';

await test('a tree is generated from a file', async (t) => {
  const source = await import_file('./tests/fixtures/test.c');

  const tree = create_tree(source);

  t.assert.ok(tree, 'The tree should be generated');
});

await test('a tree can have its default types extracted', async (t) => {
  const source = await import_file('./tests/fixtures/test.c');

  const nodes = get_nodes_from_source(source);

  t.assert.eq(
    nodes.call_expression.length,
    2,
    'The nodes should be extracted for call_expression'
  );

  t.assert.eq(
    nodes.comment.length,
    2,
    'The nodes should be extracted for comment'
  );

  const expected_call_1 = `printf("Hello, World! (%d)\\n", arg)`;

  t.assert.eq(
    text_at_position({
      source,
      start_line: nodes.call_expression[0].start_line,
      start_position: nodes.call_expression[0].start_position,
      end_line: nodes.call_expression[0].end_line,
      end_position: nodes.call_expression[0].end_position
    }),
    expected_call_1,
    'The text should match the expected content'
  );

  const expected_comment_2 = `// Call the function with an argument`;

  t.assert.eq(
    text_at_position({
      source,
      start_line: nodes.comment[1].start_line,
      start_position: nodes.comment[1].start_position,
      end_line: nodes.comment[1].end_line,
      end_position: nodes.comment[1].end_position
    }),
    expected_comment_2,
    'The text should match the expected content'
  );
});
</file>

<file path="index.mjs">
'use strict';

import './lib/file.mjs';
import './lib/functions.mjs';
</file>

</files>
